package com.example.musicplayer.mdreader

import java.io.BufferedInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

abstract class MarkdownReaderBase {

    // Regex pattern developed by Islam Kertov, thanks bro!
    // It analyze yaml front matter in markdown. Returns key in group 1 and value in group 2
    protected var frontMatterRegex = Regex(
        pattern = "(^\\w*[^: \\[\\]]): ?([\\w\\S': ]*)$",
        option = RegexOption.MULTILINE
    )
    protected var frontMatterDashesRegex = Regex(
        pattern = "^---\n",
        option = RegexOption.MULTILINE
    )


    protected open fun readFile(file: File): String {
        // Generated by Perplexity
        var result = ""
        ByteArrayOutputStream().use { buffer ->
            FileInputStream(file).use { inputStream ->
                BufferedInputStream(inputStream).use { bis ->
                    val data = ByteArray(4096)
                    var bytesRead: Int
                    while (bis.read(data, 0, data.size).also { bytesRead = it } != -1) {
                        buffer.write(data, 0, bytesRead)
                    }
                }
            }
            result = buffer.toString(Charsets.UTF_8.name())
        }
        return result
    }

    protected open fun saveMarkdown(file: File, yamlMap: Map<String, String>) {
        var text = readFile(file)
        var endIndex = frontMatterDashesRegex
            .findAll(text)
            .iterator()
            .next()
            .next()?.range?.start ?: 0
        var matches = frontMatterRegex.findAll(text)
        var hasAllKeys = false

        while (!hasAllKeys) {
            hasAllKeys = true
            for ((key, value) in yamlMap) {
                if (!text.contains("$key:") || text.indexOf("$key:") > endIndex) {
                    text = text.substring(0, endIndex) +
                            "$key: $value\n" +
                            text.substring(endIndex)
                    hasAllKeys = false
                    break
                }
            }
            matches = frontMatterRegex.findAll(text)
            endIndex = frontMatterDashesRegex
                .findAll(text)
                .iterator()
                .next()
                .next()?.range?.start ?: 0
        }

        for (match in matches) {
            if (match.range.start > endIndex)
                break

            // 0-line 1-key 2-value
            val line = match.groups[0]!!.value
            val key = match.groups[1]!!.value
            if (!yamlMap.contains(key))
                continue

            text = text.replace(line, "$key: ${yamlMap[key]}")
        }
        file.writeText(text = text)
    }

    protected open fun parseYamlFrontMatter(markdownContent: String): Map<String, String> {
        val yamlMap = mutableMapOf<String, String>()
        val endIndex = frontMatterDashesRegex
            .findAll(markdownContent)
            .iterator()
            .next()
            .next()?.range?.start ?: 0

        val matches = frontMatterRegex.findAll(markdownContent)
        for (match in matches) {
            if (match.range.start !in 0..endIndex)
                break

            // 0-line 1-key 2-value
            val key = match.groups[1]!!.value
            val value = match.groups[2]!!.value
            yamlMap[key] = value
        }
        return yamlMap
    }

    open fun toLink(str: String): String {
        val result = str.removeSurrounding("\"")
        return if (result.isNotEmpty()) "\"[[$result]]\"" else "\"$result\""
    }

    open fun unLink(str: String): String {
        return str
            .removePrefix("\"").removePrefix("[[")
            .removeSuffix("\"").removeSuffix("]]")
    }


    open fun getDateFromString(source: String): Calendar {
        val date = try {
            if (source.isNotEmpty()) {
                SimpleDateFormat(
                    "yyyy-MM-dd HH:mm:ss",
                    Locale.getDefault()
                ).parse(source)
            } else {
                Date()
            }
        } catch (_: ParseException) {
            try {
                SimpleDateFormat(
                    "yyyy-MM-dd'T'HH:mm:ssXXX",
                    Locale.getDefault()
                ).parse(source)
            } catch (_: ParseException) {
                SimpleDateFormat(
                    "yyyy-MM-dd'T'HH:mm:ss",
                    Locale.getDefault()
                ).parse(source)
            }
        }
        return Calendar
            .Builder()
            .setInstant(date)
            .build()
    }

    open fun stringArrayToList(str: String): List<String> {
        val result = mutableListOf<String>()
        val values = str.removeSurrounding(prefix = "[", suffix = "]").split("\"")
        for (i in 1..<values.size step 2)
            result.add(values[i])
        return result
    }

    open fun listToStringArray(list: List<String>): String {
        val result = list.joinToString(", ") {
            "\"${it.removeSurrounding("\"")}\""
        }
        return "[${result}]"
    }
}