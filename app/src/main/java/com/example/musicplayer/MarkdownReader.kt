package com.example.musicplayer

import android.content.Context
import android.util.Log
import androidx.core.net.toUri
import com.example.musicplayer.data.AlbumDocument
import com.example.musicplayer.data.CreatorDocument
import com.example.musicplayer.data.PlaylistDocument
import com.example.musicplayer.data.TrackDocument
import java.io.BufferedInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale


class MarkdownReader {
    companion object {
        // Yaml FrontMatter keys
        private const val CREATED_KEY = "created"
        private const val ALIASES_KEY = "aliases"
        private const val COVER_KEY = "Cover"
        private const val YEAR_KEY = "Year"
        private const val ALBUM_KEY = "Album"
        private const val CREATORS_KEY = "Creators"
        private const val NUMBER_IN_ALBUM_KEY = "NumberInAlbum"
        private const val RELATED_KEY = "related"
        private const val SOURCE_FILE_KEY = "SourceFile"
        private const val LISTEN_IN_SEC_KEY = "ListenInSec"
        private const val TRACKLIST_KEY = "tracklist"
        private const val COVER_OF_KEY = "CoverOf"

        // Regex pattern developed by Islam Kertov, thanks bro!
        // It analyze yaml front matter in markdown. Returns key in group 1 and value in group 2
        private val FrontMatterRegex = Regex(
            pattern = "(^\\w*[^: \\[\\]]): ?([\\w\\S': ]*)$",
            option = RegexOption.MULTILINE
        )
        private val FrontMatterDashesRegex = Regex(
            pattern = "^---\n",
            option = RegexOption.MULTILINE
        )
    }

    // Generated by Perplexity
    private fun readFile(file: File): String {
        var result = ""
        ByteArrayOutputStream().use { buffer ->
            FileInputStream(file).use { inputStream ->
                BufferedInputStream(inputStream).use { bis ->
                    val data = ByteArray(4096)
                    var bytesRead: Int
                    while (bis.read(data, 0, data.size).also { bytesRead = it } != -1) {
                        buffer.write(data, 0, bytesRead)
                    }
                }
            }
            result = buffer.toString(Charsets.UTF_8.name())
        }
        return result
    }

    private fun saveMarkdown(file: File, yamlMap: Map<String, String>) {
        var text = readFile(file)
        var endIndex = FrontMatterDashesRegex
            .findAll(text)
            .iterator()
            .next()
            .next()?.range?.start ?: 0
        var matches = FrontMatterRegex.findAll(text)
        var hasAllKeys = false

        while (!hasAllKeys) {
            hasAllKeys = true
            for ((key, value) in yamlMap) {
                if (!text.contains("$key:") || text.indexOf("$key:") > endIndex) {
                    text = text.substring(0, endIndex) +
                            "$key: $value\n" +
                            text.substring(endIndex)
                    hasAllKeys = false
                    break
                }
            }
            matches = FrontMatterRegex.findAll(text)
            endIndex = FrontMatterDashesRegex
                .findAll(text)
                .iterator()
                .next()
                .next()?.range?.start ?: 0
        }

        for (match in matches) {
            if (match.range.start > endIndex) {
                Log.d("TAG", "Reaches end index ${match.groups[0]!!.value}")
                break
            }
            // 0-line 1-key 2-value
            val line = match.groups[0]!!.value
            val key = match.groups[1]!!.value
            if (!yamlMap.contains(key))
                continue

            text = text.replace(line, "$key: ${yamlMap[key]}")
        }
        file.writeText(text = text)
    }

    private fun parseYamlFrontMatter(markdownContent: String): Map<String, String> {
        val yamlMap = mutableMapOf<String, String>()
        val endIndex = FrontMatterDashesRegex
            .findAll(markdownContent)
            .iterator()
            .next()
            .next()?.range?.start ?: 0

        val matches = FrontMatterRegex.findAll(markdownContent)
        for (match in matches) {
            if (match.range.start > endIndex) {
                Log.d("TAG", "Reaches end index ${match.groups[0]!!.value}")
                break
            }
            // 0-line 1-key 2-value
            val key = match.groups[1]!!.value
            val value = match.groups[2]!!.value
            yamlMap[key] = value
        }
        return yamlMap
    }

    private fun scanFolderInNotesDir(context: Context, folderName: String): List<File> {
        val notePath = getNotesFolderPath(context)
        if (notePath.isEmpty())
            return emptyList()

        val noteDir = File(getPathFromUri(notePath.toUri()))
        val dirs = noteDir.listFiles() ?: emptyArray<File>()
        for (dir in dirs) {
            if (dir.name == folderName) {
                return dir.listFiles()?.toList() ?: emptyList()
            }
        }
        return emptyList()
    }

    fun scanTracks(context: Context, allCreators: List<CreatorDocument>): List<TrackDocument> {
        val result = mutableListOf<TrackDocument>()
        val files = scanFolderInNotesDir(context, TRACKS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            val track = createTrackFromMarkdown(
                filename = file.name,
                markdownContent = readFile(file),
                allCreators = allCreators,
            )
            if (track.isValid())
                result.add(track)
        }
        return result
    }

    fun scanCreators(context: Context): List<CreatorDocument> {
        val result = mutableListOf<CreatorDocument>()
        val files = scanFolderInNotesDir(context, CREATORS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            result.add(
                createCreatorFromMarkdown(
                    filename = file.name,
                    markdownContent = readFile(file),
                )
            )
        }
        return result
    }

    fun scanAlbums(
        context: Context,
        allCreators: List<CreatorDocument>,
        allTracks: List<TrackDocument>,
    ): List<AlbumDocument> {
        val result = mutableListOf<AlbumDocument>()
        val files = scanFolderInNotesDir(context, ALBUMS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            result.add(
                createAlbumFromMarkdown(
                    filename = file.name,
                    markdownContent = readFile(file),
                    allCreators = allCreators,
                    allTracks = allTracks,
                )
            )
        }
        return result
    }

    fun scanPlaylists(context: Context, allTracks: List<TrackDocument>): List<PlaylistDocument> {
        val result = mutableListOf<PlaylistDocument>()
        val files = scanFolderInNotesDir(context, PLAYLISTS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            result.add(
                createPlaylistFromMarkdown(
                    filename = file.name,
                    markdownContent = readFile(file),
                    allTracks = allTracks,
                )
            )
        }
        return result
    }

    fun createTrackFromMarkdown(
        filename: String,
        markdownContent: String,
        allCreators: List<CreatorDocument>,
    ): TrackDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = stringArrayToList(yamlData[ALIASES_KEY].orEmpty())

        return TrackDocument(
            created = getDateFromString(source = yamlData[CREATED_KEY].orEmpty()).timeInMillis,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            cover = unLink(yamlData[COVER_KEY].orEmpty()),
            creators = stringArrayToList(yamlData[CREATORS_KEY].orEmpty())
                .mapNotNull { creatorName ->
                    allCreators.find { it.fileName == unLink(creatorName) }
                },
            year = yamlData[YEAR_KEY]?.toLongOrNull() ?: 0L,
            sourceFile = unLink(yamlData[SOURCE_FILE_KEY].orEmpty()),
            listenInSec = yamlData[LISTEN_IN_SEC_KEY]?.toIntOrNull() ?: 0,
            album = unLink(yamlData[ALBUM_KEY].orEmpty()),
            numberInAlbum = yamlData[NUMBER_IN_ALBUM_KEY]?.toLongOrNull() ?: 0L,
            related = stringArrayToList(yamlData[RELATED_KEY].orEmpty()).map { unLink(it) },
            fileName = filename.removeSuffix(".md"),
            coverOf = unLink(yamlData[COVER_OF_KEY].orEmpty())
        )
    }

    fun createCreatorFromMarkdown(
        filename: String,
        markdownContent: String,
    ): CreatorDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = stringArrayToList(yamlData[ALIASES_KEY].orEmpty())

        return CreatorDocument(
            created = getDateFromString(source = yamlData[CREATED_KEY].orEmpty()).timeInMillis,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            listenInSec = yamlData[LISTEN_IN_SEC_KEY]?.toIntOrNull() ?: 0,
            fileName = filename.removeSuffix(".md"),
        )
    }

    fun createAlbumFromMarkdown(
        filename: String,
        markdownContent: String,
        allCreators: List<CreatorDocument>,
        allTracks: List<TrackDocument>,
    ): AlbumDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = stringArrayToList(yamlData[ALIASES_KEY].orEmpty())

        return AlbumDocument(
            created = getDateFromString(source = yamlData[CREATED_KEY].orEmpty()).timeInMillis,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            cover = unLink(yamlData[COVER_KEY].orEmpty()),
            year = yamlData[YEAR_KEY]?.toLongOrNull() ?: 0L,
            creators = stringArrayToList(yamlData[CREATORS_KEY].orEmpty())
                .mapNotNull { creatorName ->
                    allCreators.find { it.fileName == unLink(creatorName) }
                },
            tracklist = stringArrayToList(yamlData[TRACKLIST_KEY].orEmpty())
                .mapNotNull { trackName ->
                    allTracks.find { it.fileName == trackName }
                },
            fileName = filename.removeSuffix(".md"),
        )
    }

    fun createPlaylistFromMarkdown(
        filename: String,
        markdownContent: String,
        allTracks: List<TrackDocument>,
    ): PlaylistDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = stringArrayToList(yamlData[ALIASES_KEY].orEmpty())

        return PlaylistDocument(
            created = getDateFromString(source = yamlData[CREATED_KEY].orEmpty()).timeInMillis,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            tracklist = stringArrayToList(yamlData[TRACKLIST_KEY].orEmpty())
                .mapNotNull { trackName ->
                    allTracks.find { it.fileName == unLink(trackName) }
                },
            fileName = filename.removeSuffix(".md"),
        )
    }

    fun saveTrack(context: Context, track: TrackDocument) {
        val files = scanFolderInNotesDir(context, TRACKS_FOLDER_NAME_IN_NOTES)
        val file = files.find { it.name == track.fileName + ".md" }
        if (file == null) {
            Log.e("TAG", "saveTrack: Not find file '${track.fileName}'")
            return
        }

        val yamlMap = mapOf(
            CREATED_KEY         to  track.getCreatedString(),
            ALIASES_KEY         to  listToStringArray(track.aliases),
            COVER_KEY           to  toLink(track.cover),
            YEAR_KEY            to  track.year.toString(),
            ALBUM_KEY           to  toLink(track.album),
            CREATORS_KEY        to  listToStringArray(
                                        list = track.creators.map { toLink(it.fileName) }),
            NUMBER_IN_ALBUM_KEY to  track.numberInAlbum.toString(),
            RELATED_KEY         to  listToStringArray(
                                        list = track.related.map { toLink(it) }),
            SOURCE_FILE_KEY     to  toLink(track.sourceFile),
            LISTEN_IN_SEC_KEY   to  track.listenInSec.toString(),
            COVER_OF_KEY        to  toLink(track.coverOf),
        )
        saveMarkdown(file, yamlMap)
    }

    fun saveCreator(context: Context, creator: CreatorDocument) {
        val files = scanFolderInNotesDir(context, CREATORS_FOLDER_NAME_IN_NOTES)
        val file = files.find { it.name == creator.fileName + ".md" }
        if (file == null) {
            Log.d("TAG", "saveCreator: Not find file '${creator.fileName}'")
            return
        }

        val yamlMap = mapOf(
            CREATED_KEY         to  creator.getCreatedString(),
            ALIASES_KEY         to  listToStringArray(creator.aliases),
            LISTEN_IN_SEC_KEY   to  creator.listenInSec.toString(),
        )
        saveMarkdown(file, yamlMap)
    }

    fun saveAlbum(context: Context, album: AlbumDocument) {
        val files = scanFolderInNotesDir(context, ALBUMS_FOLDER_NAME_IN_NOTES)
        val file = files.find { it.name == album.fileName + ".md" }
        if (file == null) {
            Log.e("TAG", "saveAlbum: Not find file '${album.fileName}'")
            return
        }

        val yamlMap = mapOf(
            CREATED_KEY     to  album.getCreatedString(),
            ALIASES_KEY     to  listToStringArray(album.aliases),
            COVER_KEY       to  toLink(album.cover),
            YEAR_KEY        to  album.year.toString(),
            CREATORS_KEY    to  listToStringArray(
                                    list = album.creators.map { toLink(it.fileName) }),
            TRACKLIST_KEY   to  listToStringArray(
                                    list = album.tracklist.map { toLink(it.fileName) }),
        )
        saveMarkdown(file, yamlMap)
    }

    fun savePlaylist(context: Context, playlist: PlaylistDocument) {
        val files = scanFolderInNotesDir(context, PLAYLISTS_FOLDER_NAME_IN_NOTES)
        val file = files.find { it.name == playlist.fileName + ".md" }
        if (file == null) {
            Log.e("TAG", "savePlaylist: Not find file '${playlist.fileName}'")
            return
        }

        val yamlMap = mapOf(
            CREATED_KEY     to  playlist.getCreatedString(),
            ALIASES_KEY     to  listToStringArray(playlist.aliases),
            TRACKLIST_KEY   to  listToStringArray(
                                    list = playlist.tracklist.map { toLink(it.fileName) }),
        )
        saveMarkdown(file, yamlMap)
    }

    fun toLink(str: String): String {
        val result = str.removeSurrounding("\"")
        return if (result.isNotEmpty()) "\"[[$result]]\"" else "\"$result\""
    }

    fun unLink(str: String): String {
        return str
            .removePrefix("\"").removePrefix("[[")
            .removeSuffix("\"").removeSuffix("]]")
    }

    fun getDateFromString(source: String): Calendar {
        val date = try {
            if (source.isNotEmpty()) {
                SimpleDateFormat(
                    "yyyy-MM-dd HH:mm:ss",
                    Locale.getDefault()
                ).parse(source)
            } else {
                Date()
            }
        } catch (_: ParseException) {
            try {
                SimpleDateFormat(
                    "yyyy-MM-dd'T'HH:mm:ssXXX",
                    Locale.getDefault()
                ).parse(source)
            } catch (_: ParseException) {
                SimpleDateFormat(
                    "yyyy-MM-dd'T'HH:mm:ss",
                    Locale.getDefault()
                ).parse(source)
            }
        }
        return Calendar
            .Builder()
            .setInstant(date)
            .build()
    }

    fun stringArrayToList(str: String): List<String> {
        val result = mutableListOf<String>()
        val values = str.removeSurrounding(prefix = "[", suffix = "]").split("\"")
        for (i in 1..<values.size step 2)
            result.add(values[i])
        return result
    }

    fun listToStringArray(list: List<String>): String {
        val result = list.joinToString(", ") {
            "\"${it.removeSurrounding("\"")}\""
        }
        return "[${result}]"
    }
}
