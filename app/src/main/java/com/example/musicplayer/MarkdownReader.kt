package com.example.musicplayer

import android.content.Context
import android.util.Log
import androidx.core.net.toUri
import com.example.musicplayer.data.AlbumDocument
import com.example.musicplayer.data.CreatorDocument
import com.example.musicplayer.data.PlaylistDocument
import com.example.musicplayer.data.TrackDocument
import org.yaml.snakeyaml.DumperOptions
import org.yaml.snakeyaml.Yaml
import java.io.BufferedInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream


class MarkdownReader {
    companion object {
        private const val ARRAY_DELIMITER = "|||"

        // Yaml FrontMatter keys
        private const val CREATED_KEY = "created"
        private const val ALIASES_KEY = "aliases"
        private const val COVER_KEY = "Cover"
        private const val YEAR_KEY = "Year"
        private const val ALBUM_KEY = "Album"
        private const val CREATORS_KEY = "Creators"
        private const val NUMBER_IN_ALBUM_KEY = "NumberInAlbum"
        private const val RELATED_KEY = "related"
        private const val SOURCE_FILE_KEY = "SourceFile"
        private const val LISTEN_IN_SEC_KEY = "ListenInSec"
        private const val TRACKLIST_KEY = "tracklist"
    }

    // Generated by Perplexity
    private fun readFile(file: File): String {
        var result = ""
        ByteArrayOutputStream().use { buffer ->
            FileInputStream(file).use { inputStream ->
                BufferedInputStream(inputStream).use { bis ->
                    val data = ByteArray(4096)
                    var bytesRead: Int
                    while (bis.read(data, 0, data.size).also { bytesRead = it } != -1) {
                        buffer.write(data, 0, bytesRead)
                    }
                }
            }
            result = buffer.toString(Charsets.UTF_8.name())
        }
        return result
    }

    private fun parseYamlFrontMatter(markdownContent: String): Map<String, String> {
        val yamlMap = mutableMapOf<String, String>()
        if (!markdownContent.startsWith("---"))
            return yamlMap

        val yamlText = markdownContent.split("---")[1].trim()
        val lines = yamlText.split("\n")
        lines.forEachIndexed { i, lineRaw ->
            val line = lineRaw.trim()

            if (line.isNotEmpty() && line.contains(":")) {
                val parts = line.split(":", limit = 2)
                val key = parts[0].trim()
                var value = if (parts.size > 1) parts[1].trim() else ""

                // Handle arrays
                if (value.isEmpty()) {
                    val arrayValues = mutableListOf<String>()
                    for (j in i+1..<lines.size) {
                        if (!lines[j].trimStart().startsWith("-"))
                            break

                        val item = lines[j]
                            .trim().substring(2) // Remove "  - " prefix
                            .removePrefix("\"").removeSuffix("\"")
                            .removePrefix("[[").removeSuffix("]]")
                        arrayValues.add(item)
                    }
                    // For arrays, join the values with a special separator to handle in conversion
                    value = if (arrayValues.isNotEmpty())
                        arrayValues.joinToString("|||")
                    else ""
                } else {
                    value = value
                        .removePrefix("\"").removeSuffix("\"")
                        .removePrefix("[[").removeSuffix("]]")
                }
                yamlMap[key] = value
            }
        }

        return yamlMap
    }

    private fun scanFolderInNotesDir(context: Context, folderName: String): List<File> {
        val notePath = getNotesFolderPath(context)
        if (notePath.isEmpty())
            return emptyList()

        val noteDir = File(getPathFromUri(notePath.toUri()))
        val dirs = noteDir.listFiles() ?: emptyArray<File>()
        for (dir in dirs) {
            if (dir.name == folderName) {
                return dir.listFiles()?.toList() ?: emptyList()
            }
        }
        return emptyList()
    }

    fun scanTracks(context: Context, allCreators: List<CreatorDocument>): List<TrackDocument> {
        val result = mutableListOf<TrackDocument>()
        val files = scanFolderInNotesDir(context, TRACKS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            val track = createTrackFromMarkdown(
                filename = file.name,
                markdownContent = readFile(file),
                allCreators = allCreators,
            )
            if (track.isValid())
                result.add(track)
        }
        return result
    }

    fun scanCreators(context: Context): List<CreatorDocument> {
        val result = mutableListOf<CreatorDocument>()
        val files = scanFolderInNotesDir(context, CREATORS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            result.add(
                createCreatorFromMarkdown(
                    filename = file.name,
                    markdownContent = readFile(file),
                )
            )
        }
        return result
    }

    fun scanAlbums(
        context: Context,
        allCreators: List<CreatorDocument>,
        allTracks: List<TrackDocument>,
    ): List<AlbumDocument> {
        val result = mutableListOf<AlbumDocument>()
        val files = scanFolderInNotesDir(context, ALBUMS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            result.add(
                createAlbumFromMarkdown(
                    filename = file.name,
                    markdownContent = readFile(file),
                    allCreators = allCreators,
                    allTracks = allTracks,
                )
            )
        }
        return result
    }

    fun scanPlaylists(context: Context, allTracks: List<TrackDocument>): List<PlaylistDocument> {
        val result = mutableListOf<PlaylistDocument>()
        val files = scanFolderInNotesDir(context, PLAYLISTS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            result.add(
                createPlaylistFromMarkdown(
                    filename = file.name,
                    markdownContent = readFile(file),
                    allTracks = allTracks,
                )
            )
        }
        return result
    }

    fun createTrackFromMarkdown(
        filename: String,
        markdownContent: String,
        allCreators: List<CreatorDocument>,
    ): TrackDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = yamlData[ALIASES_KEY]
            ?.split(ARRAY_DELIMITER)
            ?: emptyList()

        return TrackDocument(
            created = yamlData[CREATED_KEY]?.toLongOrNull() ?: 0L,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            cover = yamlData[COVER_KEY].orEmpty(),
            creators = yamlData[CREATORS_KEY]
                ?.split(ARRAY_DELIMITER)
                ?.mapNotNull { creatorName ->
                    allCreators.find { it.fileName.replace(".md", "") == creatorName }
                } ?: emptyList(),
            year = yamlData[YEAR_KEY]?.toLongOrNull() ?: 0L,
            sourceFile = yamlData[SOURCE_FILE_KEY].orEmpty(),
            listenInSec = yamlData[LISTEN_IN_SEC_KEY]?.toIntOrNull() ?: 0,
            album = yamlData[ALBUM_KEY].orEmpty(),
            numberInAlbum = yamlData[NUMBER_IN_ALBUM_KEY]?.toLongOrNull() ?: 0L,
            related = yamlData[RELATED_KEY]
                ?.split(ARRAY_DELIMITER)
                ?: emptyList(),
            fileName = filename,
        )
    }

    fun createCreatorFromMarkdown(
        filename: String,
        markdownContent: String,
    ): CreatorDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = yamlData[ALIASES_KEY]
            ?.split(ARRAY_DELIMITER)
            ?: emptyList()

        return CreatorDocument(
            created = yamlData[CREATED_KEY]?.toLongOrNull() ?: 0L,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            listenInSec = yamlData[LISTEN_IN_SEC_KEY]?.toIntOrNull() ?: 0,
            fileName = filename,
        )
    }

    fun createAlbumFromMarkdown(
        filename: String,
        markdownContent: String,
        allCreators: List<CreatorDocument>,
        allTracks: List<TrackDocument>,
    ): AlbumDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = yamlData[ALIASES_KEY]
            ?.split(ARRAY_DELIMITER)
            ?: emptyList()

        return AlbumDocument(
            created = yamlData[CREATED_KEY]?.toLongOrNull() ?: 0L,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            cover = yamlData[COVER_KEY].orEmpty(),
            year = yamlData[YEAR_KEY]?.toLongOrNull() ?: 0L,
            creators = yamlData[CREATORS_KEY]
                ?.split(ARRAY_DELIMITER)
                ?.mapNotNull { creatorName ->
                    allCreators.find { it.aliases.contains(creatorName) }
                } ?: emptyList(),
            tracklist = yamlData[TRACKLIST_KEY]
                ?.split(ARRAY_DELIMITER)
                ?.mapNotNull { trackName ->
                    allTracks.find { it.fileName == trackName }
                } ?: emptyList(),
            fileName = filename,
        )
    }

    fun createPlaylistFromMarkdown(
        filename: String,
        markdownContent: String,
        allTracks: List<TrackDocument>,
    ): PlaylistDocument {
        val yamlData = parseYamlFrontMatter(markdownContent)
        val aliases = yamlData[ALIASES_KEY]
            ?.split(ARRAY_DELIMITER)
            ?: emptyList()

        return PlaylistDocument(
            created = yamlData[CREATED_KEY]?.toLongOrNull() ?: 0L,
            aliases = aliases,
            lowerAliases = aliases.map { it.lowercase() },
            upperAliases = aliases.map { it.uppercase() },
            tracklist = yamlData[TRACKLIST_KEY]
                ?.split(ARRAY_DELIMITER)
                ?.mapNotNull { trackName ->
                    allTracks.find { it.fileName == trackName }
                } ?: emptyList(),
            fileName = filename,
        )
    }

    fun saveTrack(context: Context, track: TrackDocument) {
        val files = scanFolderInNotesDir(context, TRACKS_FOLDER_NAME_IN_NOTES)
        for (file in files) {
            if (file.name == track.fileName) {
                var text = readFile(file)
                val yamlText = text
                    .substringAfter("---")
                    .substringBefore("---")
                    .trim()
                val yamlMap = mapOf(
                    CREATED_KEY to track.getCreatedString(),
                    ALIASES_KEY to track.aliases,
                    COVER_KEY to toLink(track.cover),
                    YEAR_KEY to track.year,
                    ALBUM_KEY to toLink(track.album),
                    CREATORS_KEY to track.creators.map { toLink(it.fileName.replace(".md", "")) },
                    NUMBER_IN_ALBUM_KEY to track.numberInAlbum,
                    RELATED_KEY to track.related,
                    SOURCE_FILE_KEY to toLink(track.sourceFile),
                    LISTEN_IN_SEC_KEY to track.listenInSec,
                )
                val options = DumperOptions()
                options.defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
                options.indent = 2
                options.indentWithIndicator = true
                options.indicatorIndent = 2
                options.defaultScalarStyle = DumperOptions.ScalarStyle.PLAIN
                val yamlOutput = Yaml(options).dump(yamlMap).trim()
                text = text.replace(yamlText, yamlOutput)
                Log.d("TAG", text)
                file.writeText(text = text)
                return
            }
        }
    }

    fun toLink(str: String): String {
        return if (str.isNotEmpty()) "[[$str]]" else str
    }
}
